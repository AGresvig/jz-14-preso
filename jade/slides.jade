//Any section element inside of this container is displayed as a slide 

section
  h1 How to choose tools
  h3 Finding the right terms & avoiding the "hammer first"-principle
  p: small #[a(href='http://blog.akselgresvig.com') Aksel Gresvig] - #[a(href='http://accenture.no') Accenture] - 
    | JavaZone '14

  aside.notes(data-markdown).
    * developer, more involved lately with architecture roles
    * Fun to see frontend-concerns getting attention early on in planning
    * "frontend architect"

section
  section
    h2 What this talk is about
    ul
      li Situation: We make software (decisions)
      li Complication: The nature of our industry
      li Complication: The nature of humans
      li Conclusion: Defining terms & choosing tools is hard
      li Message: Use-case always first - then tech reqs.
      li Case in point: Web App frontend solutions

    aside.notes(data-markdown).
      * complications that makes our job tough
      * its tough to define the terms that help us make the right decisions
      * 

  section
    p I talk about frontend architecture because this is my main domain
    p But the principles discussed apply to software architecture in general

  section(data-markdown).
    ## My motivation
    * Projects using the wrong tools (and the reasons for it)
    * Blog posts like ["Why we left Angular"](https://news.ycombinator.com/item?id=7255227)

  aside.notes(data-markdown).
    * May seem obvious, but Ive seen the wrong terms over and over

  section
    h2 What's in it for you?
    h4.fragment Some hard-earned advice on what to keep in mind when planning new projects
    h4.fragment Some up-to-date insight into the frontend architecture options

section
  section
    h3 We make software
    h2.fragment Why?
    .fragment  
      p To solve problems
    
    aside.notes(data-markdown).
      * Its our job to do our best at solving the problem
      *  Need to ensure we have the technologically best possible starting point for solving the problem at hand

  section
    h2 The nature of our industry
    p ..is tiresome.  
    .fragment
      ul
        li Staying up to date demands a lot
        li There will *always* be new options around that promise the holy grail.  
        li FOSS has made the landscape so fertile, yet so vast.  

    aside.notes(data-markdown).
      * What you did last year isnt necessarily good enough anymore
      * A lot of smart people out there, solving problems every day.  
      * Latest advancements in software technology *should be considered*

section
  section
    h2 What makes it even harder is that we are human, i.e.:
    li.fragment We're #[i lazy habit makers]
    li.fragment We're #[i flock animals]
    li.fragment We're #[i impressionable]

    aside.notes(data-markdown).
      human nature makes us prone to making hasted and uneducated choices

  section(data-background='/img/lazyguyasleep.jpg').greyBg
    h2 We're lazy habit makers, who
    p do what they've done before because we're are comfortable with it
    p think new stuff is scary stuff
    p think repetition is easier than innovation
    p: small Photo: generalunitedindustries.com

  section(data-background='/img/flock_animals.jpg').greyBg
    h2 We're flock animals
    p.fragment We do whatever everyone else is doing
    blockquote.fragment AngularJS all over the scene? Must be good lets use it
    p: small Photo: Dariusz Paciorek/Getty

  section(data-background='/img/fashion_victim.JPG').greyBg
    h2 We're Impressionable
    p We believe the hype
    p Golden kid at last conference always gets attention
    p Fancy promo-site and API docs gets us (guilty!)
    p: small Photo: BRANKOPOPOVICBLOG

section
  section
    p So how do we navigate the
    h2 TECHNICAL LANDSCAPE
    p and deal with our own
    h2 LIMITATIONS?

  section
    p We ask the right
    h2 QUESTIONS
    p to find the right
    h2 ANSWERS

    aside.notes(data-markdown).
      * We need info
      * about the problem domain
      * about the user
      * about the techinical limitations

  section
    p What really matters is the 
    h1.fragment.fade-out Use Case
    h1.fragment.fade-in User

  section
    h3 Gain a #[h1 THOROUGH] understanding of your applications' problem domain
    
    aside.notes(data-markdown).
      * client
      * users 
      * research domain

  section  
    p What should the software you are building do? 
    p Who is the target user?
    p.fragment.fade-in These are matters that always #[b should take precedence]
    
    aside.notes(data-markdown).
      * when making decisions

  section
    h3 Gain a #[h1 SOLID] understanding of your applications' technical requirements

  section
    h3.cap Example Considerations
    ul 
      li.fragment Will we need a lot of user input? 
      li.fragment What are the target user's habits, and consumption devices?
      li.fragment Content-driven or data-driven?
      li.fragment Public or Private? - SEO importance
      li.fragment Requirements and desires regarding speed & responsiveness

  section
    h2 Use this info to #[h1 TAILOR] the solution to your user's needs and your technical requirements


section
  section
    h3.cap Case-study: 
    h2.cap Webapp frontend solutions
    p.fragment Lets look at webapps! After all, its what the majority of us are building these days

  section
    h2 Webapps are used by people, not machines
    p UX for your use case should be front and center when planning out the solution.

    aside.notes(data-markdown).
      UX (ease of use, intuituveness, attractiveness)

  section
    h2.cap Decisions, decisions
    ul
      li.fragment So much to choose from, something new every year
      li.fragment Last year - #[a(href='https://angularjs.org/') Angular], This year - #[a(href='http://facebook.github.io/react/') React], #[a(href='https://www.meteor.com/') Meteor]
      li.fragment Differing technical approaches to the same problems
    .fragment 
      p so 
      h3 How to choose?

    aside.notes(data-markdown).
      * Major differences that inevitably affect the user experience
section
  section
    p Lets consider some fundamentally different technical approaches
    .fragment 
      p like
      h2 Clientside rendering
      p (Backbone, Angular, Ember, Knockout)
  section
    p ..vs 
    h2 server-side rendering 
    p (JSP, Django, Ruby on Rails, Wicket, etc)
  
  section
    h3.cap Clientside frameworks 
    p Server sends Javascript to client 
    p -> execute on client 
    p -> fetch data, render UI
    p.fragment: b WHY do this on a consumer device when we have peta-zeta datacenters that can do this for us?

    aside.notes(data-markdown).
      as opposed to server-side..

  section
    p Because partial rendering and UI animations provide a 
    h3 more responsive experience

    aside.notes(data-markdown).
      * In applications with a lot dynamics (i.e. updating content), a lot of I/O, and generally data-driven platforms, this is extremely important

  section
    h3.cap Where SPAs win over traditional webapps
    li.fragment Responsive experience - no disturbing "flash of white"
    li.fragment Speed (once bootstrapped) 
    li.fragment Separation of concerns - server provides data, client handles displaying it

    aside.notes(data-markdown).
      * Fluid native-like application feel
      * Creates an efficient and pleasant experience for the end user
      * not in any way by the request/response cycles that are HTTP!

  section
    h3.cap Where traditional server-side rendering wins over SPAs
    li.fragment "Initial load"-performance - especially on slower mobile devices
    li.fragment Search engine optimization / crawlability
    
    aside.notes(data-markdown).
      * initial time-to-content can be unacceptable
      * The magic 1-second-limit 
      * Twitter make-over: reduce initial TTC by moving to server-side rendering 
      * Because the server sends data, not formatted content. It is formatted client-side, the crawlers only see the "empty" html skeleton
section
  section
    h2.cap Typical SPA based applications are
    li.fragment Behind a login (SEO not as important)
    li.fragment Data-driven, with Input being important (not just Output)
    li.fragment Web #[b apps!]

  section
    h2.cap Typical server-side based projects are
    li.fragment Public facing - SEO is important
    li.fragment Content driven
    li.fragment Fairly static (additions are common but not updates)
    li.fragment Cacheable
    li.fragment Web #[b sites!]

  section
    p There is a difference in nature between a 
    h2 WEB APP
    p and a 
    h2 WEB PAGE

    aside.notes(data-markdown).
      * Both can be built using the same underlying technologies, but the goals are very different.

  section
    p Which one are you building? 
    h3.cap This should greatly inform choice of framework

section
  section
    h1.cap The hybrid approach
    h3.fragment Is there such a thing as "best of both worlds?"
    
    aside.notes(data-markdown).
      * No such thing as "one-size-fits-all"
      * Wouldnt it be fantastic with all the upsides and few of the downsides?

section(data-background='/img/pjax.png').ghostwhite
  section
    h2 pjax
    p: code pjax = pushState + ajax
    blockquote pjax loads html from your server into the current page without a full page load

  section
    blockquote The idea is you can't tell the difference between pjax page loads and normal page loads. 
    blockquote But really it's just ajax and pushState.

    aside.notes(data-markdown).
      * Has been around since before the SPA frameworks
      * Simple, tried & tested 
      * Degrades very gracefully 

  section
    p On the client 
    pre: code.
      <body>
        <h1>My Site</h1>
        <div class="container" id="pjax-container">
          Go to <a href="/page/2">next page</a>.
        </div>
      </body>

    pre: code.javascript $(document).pjax('a', '#pjax-container')

  section
    p On the server
    pre: code.rails.
      def index
        if request.headers['X-PJAX']
          render :layout => false
        end
      end

  section
    p Why is this cool?
    p.fragment Because its simple. Simple is good
    p.fragment It gives SPA feel with server-side benefits

  section
    h3.cap But..
    p it doesn't really scale to full-size web app development

section(data-background="#000").ghostwhite
  section
    h1 Isomorphic Apps
    .fragment
      h3 Write once, run twice
      p The Holy Grail of webapp development?
    img(src='/img/isomorphic.gif')
  
    aside.notes(data-markdown).
      * Evangelized by Spike Brehm of AirBnB
      * This approach has gained traction over the past year

  section
    p Advancements in frontend tech. helps make it possible
    ul
      li.fragment #[a(href='http://nodejs.org/') Node.JS] - JS on the server
      li.fragment #[a(href='http://browserify.org/') Browserify] - use browser JS modules on the server 
      li.fragment #[a(href='http://facebook.github.io/react/') Facebooks React] - Build reactive UIs in JS 
      li.fragment #[a(href='http://pouchdb.com/') PouchDB] -  client <-> server DB syncing (replication)

  section
    b The idea:
    .fragment
      p Put common application logic in
      h3 Reusable
      p JS modules and run them where it makes sense (server or client)

  section
    p: b Examples
    ul
      li.fragment Re-use validation rules client and server-side
      li.fragment Render on the server initially, and from thereon client renders
      li.fragment Use same models/data-structure

  section(data-state="isomorphic-diagram")
    h2 Isomorphic Apps - illustration
    
    #isomorphic.canvas

    script.
      head(function(){ Reveal.addEventListener( 'isomorphic-diagram', function( event ) {
        setTimeout(function() {
          $('#isomorphic').empty();
          
          //Add a drawing area to element with id 'figure', with the given width and height
          var figure = gofigure.create('isomorphic', '703', '600'); 

          //Draw a box and animate drawing immediately
          //box <drawing area or animatable>.box(x, y, width, height, [options])
          //centeredText <drawing area or animatable>.centeredText(x, y, text, [options])
          var browserY = 100.
              browserWidth = 303;
          figure.box(3, browserY, browserWidth, 300, {radius: 0})
            .centeredText(70, browserY+20, "BROWSER", {fontsize: 27})
            .line(3, browserY+35, browserWidth, browserY+35)
            .animate();
          
          var serverX = 500,
              serverHeight = 450;
          figure.box(serverX, 10, 200, serverHeight, {radius: 0})
            .centeredText(serverX+53, 30, "SERVER", {fontsize: 27})
            .line(serverX, 42, 800, 42)
            .animate();

          //Group two animations together and begin animation immediately
          //path <drawing area or animatable>.path(points, [options])
          gofigureplugin.addStep('isomorphic', 
            figure.box(20, browserY+50, 170, 100)
              .centeredText(103, browserY+72, "Clientside logic", {fontsize: 23})
              .centeredText(100, browserY+110, "window, $, DOM")
          );
          gofigureplugin.addStep('isomorphic', 
            figure.box(serverX+15, 70, 170, 200)
              .centeredText(serverX+100, 88, "Severside logic", {fontsize: 23})
              .centeredText(serverX+90, 125, "req/res, env")
          );

          gofigureplugin.addStep('isomorphic', 
            figure.circle(serverX+145, 200, 30, {duration: 100})
              .circle(serverX+145, 215, 30, {duration: 100})
              .circle(serverX+145, 230, 30, {duration: 100})
              .circle(serverX+57, 200, 30, {duration: 100})
              .circle(serverX+57, 215, 30, {duration: 100})
              .circle(serverX+57, 230, 30, {duration: 100})
              .centeredText(serverX+100, 165, "I/O")
          );

          var opts = {arrowheads: "end", duration:500 };
          gofigureplugin.addStep('isomorphic', 
            figure.arrow(browserWidth, browserY+50, serverX, browserY+50, opts)
              .centeredText(browserWidth+100, browserY+70, "JSON Data", opts)
              .arrow(serverX, browserY+90, browserWidth, browserY+90, opts)
          );
          
          var dur = {duration: 400};
          gofigureplugin.addStep('isomorphic', 
            figure.circle(browserWidth+100, 305, 160)
              .centeredText(browserWidth+100, 265, "Common Logic", {fontsize: 23, duration: 800})             
              .centeredText(browserWidth+100, 305, "React Components", dur)
              .centeredText(browserWidth+100, 325, "Validation rules", dur)
              .centeredText(browserWidth+100, 345, "Data models", dur)
          );
        }, 1000);
      }, false);});

  section
    h2 UI rendering code sample

    pre: code.javascript.
      // Our component...
      var HelloMessage = React.createClass({
        render: function() {
          return <div>Hello {this.props.name}</div>;
        }
      });

      // ...can be rendered to a string on the server...
      React.renderComponentToString(HelloMessage({name: "John"}));

      // ...then on the client, renderComponent will preserve
      // the server-rendered markup & just attach event handlers
      React.renderComponent(< HelloMessage name="John" />, mountNode);

section
  section(data-background='/img/hipocrite.jpg').greyBg
    h2 Hi my name is Aksel, and I am a
    h1.red.loud.noshadow HIPOCRITE

  section
    h2.cap Do you see the irony?
    p.fragment I just vouched for the latest and greatest, yet-to-be tested in production, approach to building webapps.
    p.fragment #[i Exactly] this years JavaZone hype

  section
    h1 Thanks!
    h3.cap Now for the questions